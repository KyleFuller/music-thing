* Ultimately, the following things need to be present in some way or another:
    * Conjunction introduction.
    * Conjunction elimination.
    * Reductio ad absurdum.
    * Disjunction introduction.
    * Disjunction elimination.
    * Conditional introduction.
    * Conditional elimination.
    * Biconditional introduction.
    * Biconditional elimination.
    * Equality introduction.
    * Equality elimination.
    * Universal introduction.
    * Universal elimination.
    * Existential introduction.
    * Existential elimination.
    * Comprehension: must not allow any funny business (but unfortunately it still does).

* Let lowercase letters represent variables.  Unfortuntately, what I wrote below isn't too clear about what needs to be an atom and what can be any value, but if something is used as the first argument to a quantifier, it needs to be an atom.

* Let's say we only use the following built-in symbols:
    * (And p q): true iff both p and q are true.
    * (Not p): true iff p is not true.
    * (= a b): equality.
    * Forall(x, p): universal quantifier.

* Built-in Rules:
    * Propositional Calculus
        * Conjunction Introduction: Fact(p), Fact(q) -> Fact(And p q)
        * Conjunction Elimination: Fact(And p q) -> Fact(p), Fact(q)
        * Reductio Ad Absurdum: p, (Fact(p) -> Fact(And c (Not c))) -> Fact(not p)
        * Double Negation Elimination: Fact(Not (Not p)) -> Fact(p)
    * Predicate Calculus
        * Self-Identicality: a -> Fact(= a a)
        * Substitution of Equals: Fact(p{v :∈ {a, b}}), p_new@(p{v :∈ {a, b}}), Fact(= a b) -> Fact(p_new)
        * Truth: Fact(p) -> Fact(= p True)
        * Untruth: Fact(Not p) -> Fact(Not (= p True))
    * Unordered Quantified Logic
        * Universal Introduction: (y -> Fact(p{v := y})) -> Fact(Forall(z, p{v := z}))
        * Universal Elimination: Fact(Forall(x, p{v := x})), p{v := a} -> Fact(p{v := a})
        * Comprehension: Forall(x, (= (f0 x) e{v := x})) -> Fact(Forall(y, (= (f1 y) e{v := y}))) where f0 not in e and v not used as a function in e
            * This does not work;  If there is an identity function, then 
            Russell's Paradox can still be implemented.

* How it is now:
    * Built-in Rules:
        * Conditional Elimination -- To be able to have conditionals.
        * Universal Elimination -- To be able to generalize.
        * Existential Elimination -- To be able to have existentials.

        * Conditional Introduction -- To be able to capture derivation.
        * Comprehension -- To be able to get new functions from existing ones.

        * Flattening -- To be able to use a compact, n-ary syntax for multi-argument functions while ensuring all functions can still be spoken of as unary functions.

    * Axioms:
        * Equality Introduction -- To have everything be self-equal.
        * Equality Elimination Left -- Allows equating function applications based on equal functions.
        * Equality Elimination Right -- Allows equating function applications based on equal arguments.
        * Truth -- That which holds is equal to true.
        * Untruth -- That which does not hold is unequal to true.



-------- A new system, as the above system is fatally flawed --------

* Core principle: one ought not be able to use functions to determine whether or 
not a value is null.  

Built-in functions:
* And
    * And T T = T
    * And T F = F
    * And F _ = F
* Or
    * Or T _ = T
    * Or F T = T
    * Or F F = F
* Not
    * Not F = T
    * Not T = F
* If
    * If F _ = T
    * If T T = T
    * If T F = F
* Iff
    * Iff T T = T
    * Iff F F = F
* Equiv
    * Equiv x x = T
    * Equiv _@(-N) _@(-N) = F

* Quantifiers:
    * ForAll
        * ForAll x T = T
        * ForAll x _@(T|F) = F
    * Exists x <statement>
        * Exists x F = F
        * Exists x _@(T|F) = T

* Definitionally Unacceptable Operators:
    * IS_VALUE
        * IS_VALUE N = F
        * IS_VALUE _ = T
    * IS_BOOL
        * IS_BOOL _@(T|F) = T
        * IS_BOOL _ = F
    * EQUAL
        * EQUAL x x = T
        * EQUAL _ _ = F

Axioms and Rules:
* Propositional Stuff
    * Meaning of IS_BOOL
        * Boolean Intro
            * _@(ϕ | (Not ϕ))! |-> [IS_BOOL ϕ]!
        * Boolean Elim
            * [IS_BOOL ϕ]! |-> _@(ϕ | (Not ϕ))!
    * Meaning of Not
        * Reductio
            [IS_BOOL ϕ]!, (ϕ |-> ψ), (ϕ |-> (Not ψ)) |-> (Not ϕ)!
        * Double Negation Elim
            (Not (Not ϕ))! |-> ϕ!
    * Meaning of If
        * Conditional Intro
            * (ϕ! |-> ψ!) |-> (If ϕ ψ)!
        * Conditional Elim
            * (If ϕ ψ)!, ϕ! |-> ψ!
* 0-Order Predicate Stuff
    * Meaning of EQUAL
        * Equality Intro
            * a |-> [EQUAL a a]!
        * Equality Elim
            * ϕ0@(ϕ{v := _@(a|b)})!, ϕ1@(ϕ{v := _@(a|b)}), [EQUAL a b]! |-> ϕ1
* 0-Order Value Stuff
    * Meaning of Value and Equivalence
        * Equivalence Intro
            * [EQUAL a b]!, [IS_VALUE a]! |-> (Equiv a b)!
        * Equivalence Elim
            * (Equiv a b)! |-> [EQUAL a b]!, [IS_VALUE a]!
    * Uniqueness of Non-Value
        * (Not [IS_VALUE a])! |-> (EQUAL a Nul)!
    * (Statement/Expression)/(Predicate/Function) Unification
        * Truth
            * ϕ! |-> (Equiv ϕ Tru)!
        * Falsehood
            * (Not ϕ)! |-> (Equiv ϕ Fals)!
    * Value "Comprehension"
        x0, a0@(a{v := x0}) |-> x1, [EQUAL x1 a1@(a{v := x1})]!
            where x0 is an atom, and a0 contains only definitionally acceptable forms.
        a0, ϕ0@(ϕ{a := a0}) |-> a1, [EQUAL x1 a1@(a{v := x1})]!

* Quantifiers
    * Meaning of ForAll
        * Universal Intro
            (x0 |-> _@(p{v := x0})!) |-> [ForAll_ x1 _@(p{v := x1})]!
        * Universal Elim
            [ForAll_ x _@(p{v := x})]!, a |-> _@(p{v := a})!
    * Meaning of Exists
        * Existential Intro
            _@(p{v := a})! |-> [Exists_ x _@(p{v := x})]!
        * Existential Elim
            [Exists_ x _@(p{v := x})]! |-> _@(p{v := a})!
* Comprehension
    * equality-based
        * p0, x0, a0@(a{v := x0}) |-> [ForAll_ x1 [EQUAL (p1 x1) a1@(a{v := x1})]]!
            where p0 and x0 are atoms and a0 contains only definitionally acceptable forms.
    * formula-based
        * f0, x0, ϕ0@(ϕ{f := f0, x := x0}) |-> f1,
            [ForAll_ x1
                (Ifte [ExistsVal_ v
                        (If (Equiv (_f x1) v)
                            [EQUAL _@(ϕ{f := _f, x := x1}) Tru])] 
                    _@(ϕ{f := f1, x := x1})
                    (Not [IS_VALUE (f1 x1)]))]!
            where f0 and x0 are atoms and ϕ0 contains only definitionally acceptable forms.
        * High-level idea:
            * Given a generic formula expressing a property about some hypothetical function and a generic input, where the formula does not use anything that can't be used to do anything that a function shouldn't be able to do, one can have a function that has an output value that satisfies the property on all inputs on which the property can be satisfied, and no output value for all other inputs.  

            * When working algebraically with real-valued functions, we often will state a condition for a function and its inputs should satisfy.  For example, we may define z using the condition that for all pairs (x, y), x + y + z(x, y) = z(x, y) ^ 2.  Then, we find z to be a function whose domain is all and only all inputs for which the condition is satisfiable, and whose output satisfies the condition given each input.

            * Similarly, formula-based comprehension defines each new function as a function that gives the solution to a formula wherever there is a solution and is not defined elsewhere.  However, to avoid something like Russell's paradox, the formula must use only definitionally acceptable forms.
    
* Extensionality
    * [ForAll_ x [EQUAL (f x) (g x)]]!, [IS_VALUE f]!, [IS_VALUE g]! |-> [Equiv f g]!
* Null Functionality.
    * a |-> (Not [IS_VALUE (Nul a)])!
* Currying
    * Multi-argument Functions are Curried Single-Argument Functions
        (f x0..k) |-> [EQUAL (f x0..k) ((f x0..k-1) x_k)]!
            where x0..k includes k, and k >= 1.
    * A function applied with no arguments is the function itself.
        (f) |-> [EQUAL (f) f]!
* Macros
    * x0s..., _@(a{vs :.= x0s})! |-> macro, (x1s... |-> EQUAL[macro[x1s...] _@(a{vs :.= x1s})]!)
        where x0s and x1s are of the same length.